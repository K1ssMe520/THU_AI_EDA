{
    "model_name": "fp_multiplier",
    "input_node": "- clk: Clock signal (rising edge effective).\n- rst_n: Active-low reset signal.\n- A: 16-bit FP16 format input, operand one.\n- B: 16-bit FP16 format input, operand two.\n- Ready: Input data ready signal, high effective.",
    "output_node": "- C: 16-bit FP16 format output.\n- Valid: Device idle and result ready signal, high effective.",
    "specification": "- Support IEEE 754 Half-Precision Floating-Point Format (FP16):\n    - Handle all special cases (zero, infinity, NaN) as specified by IEEE 754.\n    - Ensure correct rounding to the nearest even value.\n- Use valid and ready signals for handshake. When valid is high, the input operands A and B are ready. When ready is high, the result C is valid.",
    "rtl_code": "module fp_multiplier (\n    input wire clk,\n    input wire rst_n,\n    input wire [15:0] A,\n    input wire [15:0] B,\n    input wire Ready,\n    output reg [15:0] C,\n    output reg Valid\n);\n\n    // Internal registers\n    reg [15:0] A_reg, B_reg;\n    reg [15:0] result_reg;\n    reg valid_reg;\n    reg computing;\n    \n    // FP16 format breakdown\n    wire sign_A = A_reg[15];\n    wire sign_B = B_reg[15];\n    wire [4:0] exp_A = A_reg[14:10];\n    wire [4:0] exp_B = B_reg[14:10];\n    wire [9:0] mant_A = A_reg[9:0];\n    wire [9:0] mant_B = B_reg[9:0];\n    \n    // Special case detection\n    wire A_is_zero = (exp_A == 5'b0) && (mant_A == 10'b0);\n    wire B_is_zero = (exp_B == 5'b0) && (mant_B == 10'b0);\n    wire A_is_inf = (exp_A == 5'b11111) && (mant_A == 10'b0);\n    wire B_is_inf = (exp_B == 5'b11111) && (mant_B == 10'b0);\n    wire A_is_nan = (exp_A == 5'b11111) && (mant_A != 10'b0);\n    wire B_is_nan = (exp_B == 5'b11111) && (mant_B != 10'b0);\n    \n    wire A_is_subnormal = (exp_A == 5'b0) && (mant_A != 10'b0);\n    wire B_is_subnormal = (exp_B == 5'b0) && (mant_B != 10'b0);\n    \n    // Sign calculation\n    wire result_sign = sign_A ^ sign_B;\n    \n    // Special case handling\n    wire is_nan = A_is_nan | B_is_nan | (A_is_inf & B_is_zero) | (B_is_inf & A_is_zero);\n    wire is_inf = (A_is_inf | B_is_inf) & ~is_nan;\n    wire is_zero = (A_is_zero | B_is_zero) & ~is_nan & ~is_inf;\n    \n    // Adjusted mantissas with implicit bit\n    wire [10:0] mant_A_adj = A_is_subnormal ? {1'b0, mant_A} : {1'b1, mant_A};\n    wire [10:0] mant_B_adj = B_is_subnormal ? {1'b0, mant_B} : {1'b1, mant_B};\n    \n    // Adjusted exponents\n    wire [5:0] exp_A_adj = A_is_subnormal ? 6'd1 : {1'b0, exp_A};\n    wire [5:0] exp_B_adj = B_is_subnormal ? 6'd1 : {1'b0, exp_B};\n    \n    // Multiply mantissas\n    wire [21:0] mant_product;\n    ArrayMultiplier #(\n        .WIDTH_A(11),\n        .WIDTH_B(11),\n        .OUTPUT_WIDTH(22)\n    ) mant_mult (\n        .a(mant_A_adj),\n        .b(mant_B_adj),\n        .product(mant_product)\n    );\n    \n    // Calculate exponent sum\n    wire [6:0] exp_sum = exp_A_adj + exp_B_adj - 7'd15;\n    \n    // Normalization and rounding logic\n    reg [9:0] final_mantissa;\n    reg [4:0] final_exp;\n    \n    always @(*) begin\n        if (is_nan) begin\n            final_mantissa = 10'b1111111111;\n            final_exp = 5'b11111;\n        end else if (is_inf) begin\n            final_mantissa = 10'b0;\n            final_exp = 5'b11111;\n        end else if (is_zero) begin\n            final_mantissa = 10'b0;\n            final_exp = 5'b0;\n        end else begin\n            // Normalization\n            if (mant_product[21]) begin\n                // Product >= 2, shift right\n                final_mantissa = mant_product[20:11];\n                final_exp = exp_sum[4:0] + 1'b1;\n            end else if (mant_product[20]) begin\n                // Product in [1, 2)\n                final_mantissa = mant_product[19:10];\n                final_exp = exp_sum[4:0];\n            end else begin\n                // Product < 1, shift left until normalized\n                // Simplified for this implementation\n                final_mantissa = mant_product[18:9];\n                final_exp = exp_sum[4:0] - 1'b1;\n            end\n            \n            // Handle overflow/underflow\n            if (final_exp > 5'b11110) begin // Overflow\n                final_mantissa = 10'b0;\n                final_exp = 5'b11111;\n            end else if (final_exp == 5'b0) begin // Underflow\n                final_mantissa = 10'b0;\n                final_exp = 5'b0;\n            end\n        end\n    end\n    \n    // State machine\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            A_reg <= 16'b0;\n            B_reg <= 16'b0;\n            C <= 16'b0;\n            Valid <= 1'b0;\n            computing <= 1'b0;\n        end else begin\n            if (Ready && !computing) begin\n                // Latch inputs and start computation\n                A_reg <= A;\n                B_reg <= B;\n                computing <= 1'b1;\n                Valid <= 1'b0;\n            end else if (computing) begin\n                // Complete computation\n                C <= {result_sign, final_exp, final_mantissa};\n                Valid <= 1'b1;\n                computing <= 1'b0;\n            end else if (!Ready) begin\n                Valid <= 1'b0;\n            end\n        end\n    end\n\nendmodule",
    "testbench_code": "module tb_fp_multiplier;\n    reg clk;\n    reg rst_n;\n    reg [15:0] A;\n    reg [15:0] B;\n    reg Ready;\n    wire [15:0] C;\n    wire Valid;\n    \n    // Clock generation\n    always #5 clk = ~clk;\n    \n    // DUT instantiation\n    fp_multiplier dut (\n        .clk(clk),\n        .rst_n(rst_n),\n        .A(A),\n        .B(B),\n        .Ready(Ready),\n        .C(C),\n        .Valid(Valid)\n    );\n    \n    // Test variables\n    reg [63:0] test_count;\n    reg [63:0] error_count;\n    \n    // FP16 to real conversion using basic operations\n    function real fp16_to_real;\n        input [15:0] fp16;\n        reg sign;\n        reg [4:0] exp;\n        reg [9:0] mant;\n        real result;\n        integer i;\n        real mant_val;\n        begin\n            sign = fp16[15];\n            exp = fp16[14:10];\n            mant = fp16[9:0];\n            \n            if (exp == 5'b11111) begin\n                if (mant == 10'b0) begin\n                    // Infinity\n                    fp16_to_real = sign ? -1.0e300 : 1.0e300;\n                end else begin\n                    // NaN\n                    fp16_to_real = 0.0/0.0; // This creates NaN in real\n                end\n            end else if (exp == 5'b0) begin\n                if (mant == 10'b0) begin\n                    fp16_to_real = 0.0;\n                end else begin\n                    // Subnormal\n                    mant_val = 0.0;\n                    for (i = 0; i < 10; i = i + 1) begin\n                        if (mant[9-i]) begin\n                            mant_val = mant_val + (2.0 ** (-(i+1)));\n                        end\n                    end\n                    result = mant_val * (2.0 ** -14);\n                    fp16_to_real = sign ? -result : result;\n                end\n            end else begin\n                // Normal number\n                mant_val = 1.0; // Implicit leading 1\n                for (i = 0; i < 10; i = i + 1) begin\n                    if (mant[9-i]) begin\n                        mant_val = mant_val + (2.0 ** (-(i+1)));\n                    end\n                end\n                result = mant_val * (2.0 ** (exp - 15));\n                fp16_to_real = sign ? -result : result;\n            end\n        end\n    endfunction\n    \n    // Test task\n    task test_case;\n        input [15:0] test_A;\n        input [15:0] test_B;\n        input string test_name;\n        real real_A, real_B, expected_real, actual_real;\n        begin\n            A = test_A;\n            B = test_B;\n            real_A = fp16_to_real(test_A);\n            real_B = fp16_to_real(test_B);\n            expected_real = real_A * real_B;\n            \n            Ready = 1'b1;\n            @(posedge clk);\n            Ready = 1'b0;\n            \n            wait(Valid);\n            @(posedge clk);\n            \n            actual_real = fp16_to_real(C);\n            test_count = test_count + 1;\n            \n            // Check for NaN cases\n            if ((real_A != real_A) || (real_B != real_B) || // NaN check\n                ((real_A > 1e300 || real_A < -1e300) && (real_B == 0.0)) ||\n                ((real_B > 1e300 || real_B < -1e300) && (real_A == 0.0))) begin\n                if (actual_real == actual_real) begin // If not NaN\n                    $display(\"ERROR %s: Expected NaN, got %f\", test_name, actual_real);\n                    error_count = error_count + 1;\n                end\n            end else if (((real_A > 1e300 || real_A < -1e300) && (real_B != 0.0)) || \n                       ((real_B > 1e300 || real_B < -1e300) && (real_A != 0.0))) begin\n                if (actual_real <= 1e300 && actual_real >= -1e300) begin // If not infinity\n                    $display(\"ERROR %s: Expected INF, got %f\", test_name, actual_real);\n                    error_count = error_count + 1;\n                end\n            end else if (real_A == 0.0 || real_B == 0.0) begin\n                if (actual_real != 0.0 && (actual_real == actual_real)) begin // If not zero and not NaN\n                    $display(\"ERROR %s: Expected 0.0, got %f\", test_name, actual_real);\n                    error_count = error_count + 1;\n                end\n            end else begin\n                // Compare with tolerance for floating point\n                if (actual_real != 0.0 && ((actual_real - expected_real > 0.001 * expected_real) || \n                    (expected_real - actual_real > 0.001 * expected_real))) begin\n                    $display(\"ERROR %s: A=%f, B=%f, Expected=%f, Got=%f\", \n                            test_name, real_A, real_B, expected_real, actual_real);\n                    error_count = error_count + 1;\n                end\n            end\n        end\n    endtask\n    \n    initial begin\n        // Initialize\n        clk = 0;\n        rst_n = 0;\n        A = 16'b0;\n        B = 16'b0;\n        Ready = 0;\n        test_count = 0;\n        error_count = 0;\n        \n        // Create waveform file\n        $dumpfile(\"Out/wave.vcd\");\n        $dumpvars(0, tb_fp_multiplier);\n        \n        // Reset\n        #20;\n        rst_n = 1;\n        #10;\n        \n        $display(\"Starting FP16 Multiplier Tests...\");\n        \n        // Basic Multiplication Tests\n        test_case(16'h3C00, 16'h4000, \"Positive Numbers: 1.0 * 2.0\"); // 1.0 * 2.0\n        test_case(16'hBC00, 16'h4000, \"Negative * Positive: -1.0 * 2.0\"); // -1.0 * 2.0\n        test_case(16'hBC00, 16'hC000, \"Negative Numbers: -1.0 * -2.0\"); // -1.0 * -2.0\n        \n        // Zero Multiplication Tests\n        test_case(16'h0000, 16'h3C00, \"Zero * Positive: 0.0 * 1.0\"); // 0.0 * 1.0\n        test_case(16'h3C00, 16'h0000, \"Positive * Zero: 1.0 * 0.0\"); // 1.0 * 0.0\n        test_case(16'h8000, 16'h3C00, \"Negative Zero * Positive: -0.0 * 1.0\"); // -0.0 * 1.0\n        \n        // Infinity Multiplication Tests\n        test_case(16'h7C00, 16'h3C00, \"INF * Positive: INF * 1.0\"); // INF * 1.0\n        test_case(16'hFC00, 16'h3C00, \"-INF * Positive: -INF * 1.0\"); // -INF * 1.0\n        test_case(16'h7C00, 16'h0000, \"INF * Zero: INF * 0.0\"); // INF * 0.0 (should be NaN)\n        \n        // NaN Multiplication Tests\n        test_case(16'h7E00, 16'h3C00, \"NaN * Positive: NaN * 1.0\"); // NaN * 1.0\n        test_case(16'h3C00, 16'h7E00, \"Positive * NaN: 1.0 * NaN\"); // 1.0 * NaN\n        \n        // Subnormal Numbers Tests\n        test_case(16'h0001, 16'h0001, \"Subnormal * Subnormal: 5.96e-8 * 5.96e-8\");\n        test_case(16'h0001, 16'h3C00, \"Subnormal * Normal: 5.96e-8 * 1.0\");\n        \n        // Overflow and Underflow Tests\n        test_case(16'h7BFF, 16'h4000, \"Overflow: MAX * 2.0\"); // ~65504 * 2.0\n        test_case(16'h0001, 16'h0001, \"Underflow: MIN * MIN\"); // 5.96e-8 * 5.96e-8\n        \n        // Edge Cases\n        test_case(16'h7BFF, 16'h3E00, \"Max Value * 1.5\"); // ~65504 * 1.5\n        test_case(16'h0001, 16'h0001, \"Min Value * Min Value\"); // 5.96e-8 * 5.96e-8\n        \n        // Wait for completion\n        #100;\n        \n        // Summary\n        $display(\"\\nTest Summary:\");\n        $display(\"Total Tests: %0d\", test_count);\n        $display(\"Errors: %0d\", error_count);\n        \n        if (error_count == 0) begin\n            $display(\"TestSuccessed\");\n        end else begin\n            $display(\"TestFailed\");\n        end\n        \n        $finish;\n    end\n\nendmodule",
    "test_spec": "- TestBench should contain the following test conditions:\n    - Basic Multiplication: Positive numbers (e.g., 2.0 * 3.0); Negative numbers (e.g., -2.0 * 3.0); Mixed signs (e.g., -2.0 * -3.0);\n    - Zero Multiplication: Multiplication involving zero (e.g., 0.0 * 2.0);\n    - Infinity Multiplication: Multiplication involving infinity (e.g., inf * 2.0);\n    - NaN Multiplication: Multiplication involving NaN (e.g., NaN * 2.0);\n    - Subnormal Numbers: Multiplication involving very small numbers (e.g., 5.96e-8 * 5.96e-8);\n    - Overflow and Underflow: Test cases that result in overflow or underflow;\n    - Edge Cases: Multiplication of maximum representable values (e.g., 65504.0 * 1.5); Multiplication of minimum representable values (e.g., 5.96e-8 * 5.96e-8);",
    "RelatedID": [
        1,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        12
    ],
    "SimulationResult": "./Test/tb_fp_multiplier.sv:69: syntax error\n./Test/tb_fp_multiplier.sv:69: error: Malformed statement\n\nOut/out.vvp: Unable to open input file.\n\n"
}