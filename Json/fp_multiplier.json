{
    "model_name": "fp_multiplier",
    "input_node": "- clk: Clock signal (rising edge effective).\n- rst_n: Active-low reset signal.\n- A: 16-bit FP16 format input, operand one.\n- B: 16-bit FP16 format input, operand two.\n- Ready: Input data ready signal, high effective.",
    "output_node": "- C: 16-bit FP16 format output.\n- Valid: Device idle and result ready signal, high effective.",
    "specification": "- Support IEEE 754 Half-Precision Floating-Point Format (FP16):\n    - Handle all special cases (zero, infinity, NaN) as specified by IEEE 754.\n    - Ensure correct rounding to the nearest even value.\n- Use valid and ready signals for handshake. When valid is high, the input operands A and B are ready. When ready is high, the result C is valid.",
    "rtl_code": "module fp_multiplier (\n    input clk,\n    input rst_n,\n    input [15:0] A,\n    input [15:0] B,\n    input Ready,\n    output reg [15:0] C,\n    output reg Valid\n);\n\n// Pipeline stage 0: Input registration\nreg [15:0] A_reg, B_reg;\nreg Ready_reg;\n\n// Pipeline stage 1: Special case detection and mantissa extraction\nreg sign_A_reg, sign_B_reg;\nreg [4:0] exp_A_reg, exp_B_reg;\nreg [9:0] mant_A_reg, mant_B_reg;\nreg sign_C_reg;\nreg C_is_nan_reg, C_is_inf_reg, C_is_zero_reg;\nreg Ready_reg1;\n\n// Pipeline stage 2: Multiplication and normalization\nreg [21:0] product_sig_reg;\nreg signed [5:0] exp_sum_unbiased_reg;\nreg sign_C_reg2;\nreg C_is_nan_reg2, C_is_inf_reg2, C_is_zero_reg2;\nreg Ready_reg2;\n\n// Pipeline stage 3: Rounding and final result\nreg [15:0] computed_C_reg;\nreg Ready_reg3;\n\n// Extract components from A and B\nwire sign_A = A_reg[15];\nwire [4:0] exp_A = A_reg[14:10];\nwire [9:0] mant_A = A_reg[9:0];\nwire sign_B = B_reg[15];\nwire [4:0] exp_B = B_reg[14:10];\nwire [9:0] mant_B = B_reg[9:0];\n\n// Special case detection\nwire A_is_zero = (exp_A == 5'b0) && (mant_A == 10'b0);\nwire A_is_inf = (exp_A == 5'b11111) && (mant_A == 10'b0);\nwire A_is_nan = (exp_A == 5'b11111) && (mant_A != 10'b0);\nwire B_is_zero = (exp_B == 5'b0) && (mant_B == 10'b0);\nwire B_is_inf = (exp_B == 5'b11111) && (mant_B == 10'b0);\nwire B_is_nan = (exp_B == 5'b11111) && (mant_B != 10'b0);\n\nwire sign_C = sign_A ^ sign_B;\nwire C_is_nan = A_is_nan || B_is_nan || (A_is_inf && B_is_zero) || (A_is_zero && B_is_inf);\nwire C_is_inf = (A_is_inf || B_is_inf) && !C_is_nan;\nwire C_is_zero = (A_is_zero || B_is_zero) && !C_is_nan;\n\n// Normal case signals\nwire [10:0] sig_A_int = (exp_A == 5'b0) ? {1'b0, mant_A} : {1'b1, mant_A};\nwire [10:0] sig_B_int = (exp_B == 5'b0) ? {1'b0, mant_B} : {1'b1, mant_B};\nwire [21:0] product_sig = sig_A_int * sig_B_int;\n\n// Unbiased exponents\nwire signed [5:0] exp_A_unbiased = (exp_A == 5'b0) ? -6'sd14 : ($signed({1'b0, exp_A}) - 6'sd15);\nwire signed [5:0] exp_B_unbiased = (exp_B == 5'b0) ? -6'sd14 : ($signed({1'b0, exp_B}) - 6'sd15);\nwire signed [5:0] exp_sum_unbiased = exp_A_unbiased + exp_B_unbiased;\n\n// Pipeline stage 0: Register inputs\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        A_reg <= 16'b0;\n        B_reg <= 16'b0;\n        Ready_reg <= 1'b0;\n    end else begin\n        A_reg <= A;\n        B_reg <= B;\n        Ready_reg <= Ready;\n    end\nend\n\n// Pipeline stage 1: Extract and detect special cases\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        sign_A_reg <= 1'b0;\n        sign_B_reg <= 1'b0;\n        exp_A_reg <= 5'b0;\n        exp_B_reg <= 5'b0;\n        mant_A_reg <= 10'b0;\n        mant_B_reg <= 10'b0;\n        sign_C_reg <= 1'b0;\n        C_is_nan_reg <= 1'b0;\n        C_is_inf_reg <= 1'b0;\n        C_is_zero_reg <= 1'b0;\n        Ready_reg1 <= 1'b0;\n    end else begin\n        sign_A_reg <= sign_A;\n        sign_B_reg <= sign_B;\n        exp_A_reg <= exp_A;\n        exp_B_reg <= exp_B;\n        mant_A_reg <= mant_A;\n        mant_B_reg <= mant_B;\n        sign_C_reg <= sign_C;\n        C_is_nan_reg <= C_is_nan;\n        C_is_inf_reg <= C_is_inf;\n        C_is_zero_reg <= C_is_zero;\n        Ready_reg1 <= Ready_reg;\n    end\nend\n\n// Pipeline stage 2: Multiplication and normalization\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        product_sig_reg <= 22'b0;\n        exp_sum_unbiased_reg <= 6'b0;\n        sign_C_reg2 <= 1'b0;\n        C_is_nan_reg2 <= 1'b0;\n        C_is_inf_reg2 <= 1'b0;\n        C_is_zero_reg2 <= 1'b0;\n        Ready_reg2 <= 1'b0;\n    end else begin\n        product_sig_reg <= product_sig;\n        exp_sum_unbiased_reg <= exp_sum_unbiased;\n        sign_C_reg2 <= sign_C_reg;\n        C_is_nan_reg2 <= C_is_nan_reg;\n        C_is_inf_reg2 <= C_is_inf_reg;\n        C_is_zero_reg2 <= C_is_zero_reg;\n        Ready_reg2 <= Ready_reg1;\n    end\nend\n\n// Normalization logic (combinatorial)\nreg [21:0] product_sig_shifted;\nreg signed [5:0] exp_shifted;\nreg G;\nreg Sticky;\n\nalways @* begin\n    integer L;\n    integer shift_count;\n    reg sticky_temp;\n    integer i;\n    \n    // Find leading one\n    L = 21;\n    while (L >= 0 && product_sig_reg[L] == 1'b0) begin\n        L = L - 1;\n    end\n    if (L < 0) L = 0;\n\n    // Normalization\n    if (L < 10) begin\n        shift_count = 10 - L;\n        product_sig_shifted = product_sig_reg << shift_count;\n        exp_shifted = exp_sum_unbiased_reg - shift_count;\n        G = 1'b0;\n        Sticky = 1'b0;\n    end else if (L > 10) begin\n        shift_count = L - 10;\n        product_sig_shifted = product_sig_reg >> shift_count;\n        exp_shifted = exp_sum_unbiased_reg + shift_count;\n        G = product_sig_reg[shift_count - 1];\n        sticky_temp = 1'b0;\n        for (i = 0; i < shift_count - 1; i = i + 1) begin\n            sticky_temp = sticky_temp | product_sig_reg[i];\n        end\n        Sticky = sticky_temp;\n    end else begin\n        product_sig_shifted = product_sig_reg;\n        exp_shifted = exp_sum_unbiased_reg;\n        G = 1'b0;\n        Sticky = 1'b0;\n    end\nend\n\n// Significand after normalization\nwire [10:0] S = product_sig_shifted[10:0];\n\n// Round to nearest even\nwire round_up = G && (Sticky || S[0]);\nwire [11:0] S_rounded_temp = round_up ? {1'b0, S} + 1 : {1'b0, S};\nwire [10:0] S_final = S_rounded_temp[11] ? 11'b10000000000 : S_rounded_temp[10:0];\nwire signed [5:0] exp_final = S_rounded_temp[11] ? exp_shifted + 1 : exp_shifted;\n\n// Check for underflow and overflow\nwire [15:0] C_normal;\nassign C_normal = (exp_final < -14) ? {sign_C_reg2, 5'b0, 10'b0} :\n                  (exp_final > 15) ? {sign_C_reg2, 5'b11111, 10'b0} :\n                  {sign_C_reg2, exp_final + 5'sd15, S_final[9:0]};\n\n// Final computed C\nwire [15:0] computed_C;\nassign computed_C = C_is_nan_reg2 ? 16'h7E00 :\n                    C_is_inf_reg2 ? {sign_C_reg2, 5'b11111, 10'b0} :\n                    C_is_zero_reg2 ? {sign_C_reg2, 5'b0, 10'b0} :\n                    C_normal;\n\n// Pipeline stage 3: Final output\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        computed_C_reg <= 16'b0;\n        Ready_reg3 <= 1'b0;\n    end else begin\n        computed_C_reg <= computed_C;\n        Ready_reg3 <= Ready_reg2;\n    end\nend\n\n// Final output assignment\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        Valid <= 1'b0;\n        C <= 16'b0;\n    end else begin\n        Valid <= Ready_reg3;\n        C <= computed_C_reg;\n    end\nend\n\nendmodule",
    "testbench_code": "module tb_fp_multiplier;\n\nreg clk;\nreg rst_n;\nreg Ready;\nreg [15:0] A;\nreg [15:0] B;\nwire [15:0] C;\nwire Valid;\n\nfp_multiplier dut (\n    .clk(clk),\n    .rst_n(rst_n),\n    .A(A),\n    .B(B),\n    .Ready(Ready),\n    .C(C),\n    .Valid(Valid)\n);\n\ninitial begin\n    clk = 0;\n    forever #5 clk = ~clk;\nend\n\ninitial begin\n    rst_n = 0;\n    #10;\n    rst_n = 1;\nend\n\ninitial begin\n    Ready = 0;\n    A = 0;\n    B = 0;\n    @(posedge rst_n);\n    #10;\n\n    test_case(16'h4000, 16'h4200, 16'h4600, \"2.0 * 3.0 = 6.0\");\n    test_case(16'hC000, 16'h4200, 16'hC600, \"-2.0 * 3.0 = -6.0\");\n    test_case(16'hC000, 16'hC200, 16'h4600, \"-2.0 * -3.0 = 6.0\");\n    test_case(16'h0000, 16'h4200, 16'h0000, \"0.0 * 3.0 = 0.0\");\n    test_case(16'h7C00, 16'h4200, 16'h7C00, \"inf * 3.0 = inf\");\n    test_case(16'h7E00, 16'h4200, 16'h7E00, \"NaN * 3.0 = NaN\");\n    test_case(16'h0001, 16'h0001, 16'h0000, \"5.96e-8 * 5.96e-8 = 0.0\");\n    test_case(16'h7BFF, 16'h3E00, 16'h7C00, \"65504.0 * 1.5 = inf\");\n    test_case(16'h7BFF, 16'h7BFF, 16'h7C00, \"65504.0 * 65504.0 = inf\");\n    test_case(16'h0001, 16'h0001, 16'h0000, \"min * min = 0\");\n\n    $display(\"TestSuccessed\");\n    $finish;\nend\n\ntask test_case(input [15:0] a, input [15:0] b, input [15:0] expected_c, string name);\n    begin\n        A = a;\n        B = b;\n        Ready = 1;\n        @(posedge clk);\n        Ready = 0;\n        // Wait for result (4 clock cycles for pipelined design)\n        repeat(4) @(posedge clk);\n        if (Valid !== 1'b1) begin\n            $display(\"Error: Valid not high for test %s\", name);\n            $finish;\n        end\n        if (C !== expected_c) begin\n            $display(\"Error: for test %s, expected %h, got %h\", name, expected_c, C);\n            $finish;\n        end\n        $display(\"Pass: %s\", name);\n    end\nendtask\n\nendmodule",
    "test_spec": "- TestBench should contain the following test conditions:\n    - Basic Multiplication: Positive numbers (e.g., 2.0 * 3.0); Negative numbers (e.g., -2.0 * 3.0); Mixed signs (e.g., -2.0 * -3.0);\n    - Zero Multiplication: Multiplication involving zero (e.g., 0.0 * 2.0);\n    - Infinity Multiplication: Multiplication involving infinity (e.g., inf * 2.0);\n    - NaN Multiplication: Multiplication involving NaN (e.g., NaN * 2.0);\n    - Subnormal Numbers: Multiplication involving very small numbers (e.g., 5.96e-8 * 5.96e-8);\n    - Overflow and Underflow: Test cases that result in overflow or underflow;\n    - Edge Cases: Multiplication of maximum representable values (e.g., 65504.0 * 1.5); Multiplication of minimum representable values (e.g., 5.96e-8 * 5.96e-8);",
    "RelatedID": [],
    "SimulationResult": "\nError: Valid not high for test 2.0 * 3.0 = 6.0\n./Test/tb_fp_multiplier.sv:65: $finish called at 65 (1s)\n\n"
}