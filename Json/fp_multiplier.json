{
    "model_name": "fp_multiplier",
    "input_node": "- clk: Clock signal (rising edge effective).\n- rst_n: Active-low reset signal.\n- A: 16-bit FP16 format input, operand one.\n- B: 16-bit FP16 format input, operand two.\n- Ready: Input data ready signal, high effective.",
    "output_node": "- C: 16-bit FP16 format output.\n- Valid: Device idle and result ready signal, high effective.",
    "specification": "- Support IEEE 754 Half-Precision Floating-Point Format (FP16):\n    - Handle all special cases (zero, infinity, NaN) as specified by IEEE 754.\n    - Ensure correct rounding to the nearest even value.\n- Use valid and ready signals for handshake. When valid is high, the input operands A and B are ready. When ready is high, the result C is valid.\n- TestBench should contain the following test conditions:\n    - Basic Multiplication: Positive numbers (e.g., 2.0 * 3.0); Negative numbers (e.g., -2.0 * 3.0); Mixed signs (e.g., -2.0 * -3.0);\n    - Zero Multiplication: Multiplication involving zero (e.g., 0.0 * 2.0);\n    - Infinity Multiplication: Multiplication involving infinity (e.g., inf * 2.0);\n    - NaN Multiplication: Multiplication involving NaN (e.g., NaN * 2.0);\n    - Subnormal Numbers: Multiplication involving very small numbers (e.g., 5.96e-8 * 5.96e-8);\n    - Overflow and Underflow: Test cases that result in overflow or underflow;\n    - Edge Cases: Multiplication of maximum representable values (e.g., 65504.0 * 1.5); Multiplication of minimum representable values (e.g., 5.96e-8 * 5.96e-8);",
    "rtl_code": "module fp_multiplier (\n    input wire clk,\n    input wire rst_n,\n    input wire [15:0] A,\n    input wire [15:0] B,\n    input wire Ready,\n    output reg [15:0] C,\n    output reg Valid\n);\n\n    // IEEE 754 FP16 format breakdown\n    wire A_sign = A[15];\n    wire [4:0] A_exp = A[14:10];\n    wire [9:0] A_frac = A[9:0];\n    \n    wire B_sign = B[15];\n    wire [4:0] B_exp = B[14:10];\n    wire [9:0] B_frac = B[9:0];\n    \n    // Special case detection\n    wire A_is_zero = (A_exp == 5'b0) && (A_frac == 10'b0);\n    wire A_is_inf = (A_exp == 5'b11111) && (A_frac == 10'b0);\n    wire A_is_nan = (A_exp == 5'b11111) && (A_frac != 10'b0);\n    wire A_is_subnormal = (A_exp == 5'b0) && (A_frac != 10'b0);\n    \n    wire B_is_zero = (B_exp == 5'b0) && (B_frac == 10'b0);\n    wire B_is_inf = (B_exp == 5'b11111) && (B_frac == 10'b0);\n    wire B_is_nan = (B_exp == 5'b11111) && (B_frac != 10'b0);\n    wire B_is_subnormal = (B_exp == 5'b0) && (B_frac != 10'b0);\n    \n    // Pipeline registers\n    reg [1:0] stage;\n    reg [15:0] A_reg, B_reg;\n    reg ready_reg;\n    \n    // Intermediate calculation registers\n    reg result_sign;\n    reg [5:0] result_exp;\n    reg [20:0] result_frac; // 11-bit product (10+10+1) + 10 bits for rounding\n    \n    // Output register\n    reg [15:0] C_next;\n    reg valid_next;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            stage <= 0;\n            A_reg <= 0;\n            B_reg <= 0;\n            ready_reg <= 0;\n            result_sign <= 0;\n            result_exp <= 0;\n            result_frac <= 0;\n            C <= 16'h0000;\n            Valid <= 0;\n        end else begin\n            ready_reg <= Ready;\n            \n            if (Ready && !ready_reg) begin\n                // Stage 0: Input latch and special case detection\n                stage <= 1;\n                A_reg <= A;\n                B_reg <= B;\n            end else if (stage == 1) begin\n                // Stage 1: Main calculation\n                stage <= 2;\n                \n                // Handle special cases\n                if (A_is_nan || B_is_nan) begin\n                    // NaN * anything = NaN\n                    C_next <= 16'h7E00; // Quiet NaN\n                    valid_next <= 1;\n                end else if ((A_is_zero && B_is_inf) || (A_is_inf && B_is_zero)) begin\n                    // 0 * inf = NaN\n                    C_next <= 16'h7E00; // Quiet NaN\n                    valid_next <= 1;\n                end else if (A_is_inf || B_is_inf) begin\n                    // inf * anything (except NaN and 0) = inf\n                    result_sign = A_sign ^ B_sign;\n                    C_next <= {result_sign, 5'b11111, 10'b0};\n                    valid_next <= 1;\n                end else if (A_is_zero || B_is_zero) begin\n                    // 0 * anything (except NaN and inf) = 0\n                    result_sign = A_sign ^ B_sign;\n                    C_next <= {result_sign, 15'b0};\n                    valid_next <= 1;\n                end else begin\n                    // Normal multiplication\n                    result_sign = A_sign ^ B_sign;\n                    \n                    // Add exponents and subtract bias (15)\n                    result_exp = {1'b0, A_exp} + {1'b0, B_exp} - 6'd15;\n                    \n                    // Prepare mantissas with hidden bit\n                    reg [10:0] A_mantissa, B_mantissa;\n                    if (A_is_subnormal) begin\n                        A_mantissa = {1'b0, A_frac};\n                    end else begin\n                        A_mantissa = {1'b1, A_frac};\n                    end\n                    \n                    if (B_is_subnormal) begin\n                        B_mantissa = {1'b0, B_frac};\n                    end else begin\n                        B_mantissa = {1'b1, B_frac};\n                    end\n                    \n                    // Multiply mantissas (11-bit * 11-bit = 22-bit product)\n                    result_frac = A_mantissa * B_mantissa;\n                    \n                    valid_next <= 0;\n                end\n            end else if (stage == 2) begin\n                // Stage 2: Normalization and rounding\n                stage <= 0;\n                \n                if (!valid_next) begin\n                    // Normalize the product\n                    if (result_frac[20]) begin\n                        // Product >= 2.0, shift right and increment exponent\n                        result_frac = result_frac >> 1;\n                        result_exp = result_exp + 1;\n                    end\n                    \n                    // Check for overflow/underflow\n                    if (result_exp[5] || (result_exp < 6'd1)) begin\n                        // Underflow - result is subnormal or zero\n                        if (result_exp < 6'd-10) begin\n                            // Severe underflow - result is zero\n                            C_next <= {result_sign, 15'b0};\n                        end else begin\n                            // Subnormal result\n                            integer shift_amount = 1 - result_exp;\n                            result_frac = result_frac >> shift_amount;\n                            C_next <= {result_sign, 5'b0, result_frac[19:10]};\n                        end\n                    end else if (result_exp > 6'd30) begin\n                        // Overflow - result is infinity\n                        C_next <= {result_sign, 5'b11111, 10'b0};\n                    end else begin\n                        // Normal result\n                        // Round to nearest even\n                        reg [9:0] rounded_frac;\n                        if (result_frac[9] && (result_frac[8:0] != 0 || result_frac[10])) begin\n                            rounded_frac = result_frac[19:10] + 1;\n                            if (rounded_frac[10]) begin // Carry occurred\n                                rounded_frac = rounded_frac >> 1;\n                                result_exp = result_exp + 1;\n                                if (result_exp > 6'd30) begin\n                                    C_next <= {result_sign, 5'b11111, 10'b0};\n                                end else begin\n                                    C_next <= {result_sign, result_exp[4:0], rounded_frac[9:0]};\n                                end\n                            end else begin\n                                C_next <= {result_sign, result_exp[4:0], rounded_frac[9:0]};\n                            end\n                        end else begin\n                            C_next <= {result_sign, result_exp[4:0], result_frac[19:10]};\n                        end\n                    end\n                    valid_next <= 1;\n                end\n                \n                C <= C_next;\n                Valid <= valid_next;\n            end else begin\n                Valid <= 0;\n            end\n        end\n    end\n\nendmodule",
    "testbench_code": "module fp_multiplier_tb;\n    // Parameters\n    parameter CLK_PERIOD = 10;\n    \n    // Signals\n    reg clk;\n    reg rst_n;\n    reg [15:0] A;\n    reg [15:0] B;\n    reg Ready;\n    wire [15:0] C;\n    wire Valid;\n    \n    // Test variables\n    integer error_count;\n    integer test_case;\n    real expected_result;\n    real actual_result;\n    \n    // Instantiate DUT\n    fp_multiplier dut (\n        .clk(clk),\n        .rst_n(rst_n),\n        .A(A),\n        .B(B),\n        .Ready(Ready),\n        .C(C),\n        .Valid(Valid)\n    );\n    \n    // Clock generation\n    always #(CLK_PERIOD/2) clk = ~clk;\n    \n    // Convert FP16 to real\n    function real fp16_to_real;\n        input [15:0] fp16;\n        reg sign;\n        reg [4:0] exp;\n        reg [9:0] frac;\n        real result;\n        integer i;\n        begin\n            sign = fp16[15];\n            exp = fp16[14:10];\n            frac = fp16[9:0];\n            \n            if (exp == 5'b11111) begin\n                if (frac == 10'b0) begin\n                    result = sign ? -$itor(1.0)/0.0 : $itor(1.0)/0.0; // Infinity\n                end else begin\n                    result = 0.0/0.0; // NaN\n                end\n            end else if (exp == 5'b0) begin\n                if (frac == 10'b0) begin\n                    result = 0.0;\n                end else begin\n                    // Subnormal number\n                    result = $itor(frac) * (2.0 ** -24);\n                    if (sign) result = -result;\n                end\n            end else begin\n                // Normal number\n                result = (1.0 + $itor(frac) * (2.0 ** -10)) * (2.0 ** ($itor(exp) - 15));\n                if (sign) result = -result;\n            end\n            \n            fp16_to_real = result;\n        end\n    endfunction\n    \n    // Waveform dumping\n    initial begin\n        $dumpfile(\"Out/wave.vcd\");\n        $dumpvars(0, fp_multiplier_tb);\n    end\n    \n    // Test tasks\n    task reset_dut;\n        begin\n            rst_n = 0;\n            Ready = 0;\n            A = 0;\n            B = 0;\n            @(posedge clk);\n            @(posedge clk);\n            rst_n = 1;\n            @(posedge clk);\n        end\n    endtask\n    \n    task multiply_inputs;\n        input [15:0] a_val;\n        input [15:0] b_val;\n        begin\n            A = a_val;\n            B = b_val;\n            Ready = 1;\n            @(posedge clk);\n            Ready = 0;\n            \n            // Wait for result\n            while (!Valid) @(posedge clk);\n            @(posedge clk);\n        end\n    endtask\n    \n    task check_result;\n        input [15:0] actual;\n        input real expected;\n        input string test_name;\n        real actual_real;\n        begin\n            actual_real = fp16_to_real(actual);\n            \n            // Handle special cases\n            if ($isnan(expected) && $isnan(actual_real)) begin\n                // Both are NaN - this is correct\n                $display(\"PASS: %s - Expected NaN, Got NaN\", test_name);\n            end else if (!$isnan(expected) && !$isnan(actual_real) && \n                        (actual_real == expected || \n                         (($abs(actual_real - expected) / $abs(expected)) < 1e-3))) begin\n                // Values match within tolerance\n                $display(\"PASS: %s - Expected: %e, Got: %e\", test_name, expected, actual_real);\n            end else begin\n                $display(\"ERROR: %s - Expected: %e, Got: %e\", test_name, expected, actual_real);\n                error_count = error_count + 1;\n            end\n        end\n    endtask\n    \n    // Main test sequence\n    initial begin\n        // Initialize\n        clk = 0;\n        error_count = 0;\n        test_case = 0;\n        \n        // Test 1: Reset behavior\n        test_case = 1;\n        $display(\"Test %0d: Reset Behavior\", test_case);\n        reset_dut();\n        \n        // Test 2: Basic Multiplication - Positive numbers\n        test_case = 2;\n        $display(\"Test %0d: Basic Multiplication - Positive Numbers\", test_case);\n        reset_dut();\n        \n        multiply_inputs(16'h4000, 16'h4200); // 2.0 * 3.0 = 6.0\n        check_result(C, 6.0, \"2.0 * 3.0\");\n        \n        multiply_inputs(16'h3C00, 16'h3C00); // 1.0 * 1.0 = 1.0\n        check_result(C, 1.0, \"1.0 * 1.0\");\n        \n        // Test 3: Basic Multiplication - Negative numbers\n        test_case = 3;\n        $display(\"Test %0d: Basic Multiplication - Negative Numbers\", test_case);\n        reset_dut();\n        \n        multiply_inputs(16'hC000, 16'h4200); // -2.0 * 3.0 = -6.0\n        check_result(C, -6.0, \"-2.0 * 3.0\");\n        \n        multiply_inputs(16'h4000, 16'hC200); // 2.0 * -3.0 = -6.0\n        check_result(C, -6.0, \"2.0 * -3.0\");\n        \n        // Test 4: Basic Multiplication - Mixed signs\n        test_case = 4;\n        $display(\"Test %0d: Basic Multiplication - Mixed Signs\", test_case);\n        reset_dut();\n        \n        multiply_inputs(16'hC000, 16'hC200); // -2.0 * -3.0 = 6.0\n        check_result(C, 6.0, \"-2.0 * -3.0\");\n        \n        // Test 5: Zero Multiplication\n        test_case = 5;\n        $display(\"Test %0d: Zero Multiplication\", test_case);\n        reset_dut();\n        \n        multiply_inputs(16'h0000, 16'h4000); // 0.0 * 2.0 = 0.0\n        check_result(C, 0.0, \"0.0 * 2.0\");\n        \n        multiply_inputs(16'h8000, 16'h4000); // -0.0 * 2.0 = -0.0\n        check_result(C, -0.0, \"-0.0 * 2.0\");\n        \n        // Test 6: Infinity Multiplication\n        test_case = 6;\n        $display(\"Test %0d: Infinity Multiplication\", test_case);\n        reset_dut();\n        \n        multiply_inputs(16'h7C00, 16'h4000); // inf * 2.0 = inf\n        check_result(C, $itor(1.0)/0.0, \"inf * 2.0\");\n        \n        multiply_inputs(16'hFC00, 16'h4000); // -inf * 2.0 = -inf\n        check_result(C, -$itor(1.0)/0.0, \"-inf * 2.0\");\n        \n        // Test 7: NaN Multiplication\n        test_case = 7;\n        $display(\"Test %0d: NaN Multiplication\", test_case);\n        reset_dut();\n        \n        multiply_inputs(16'h7E00, 16'h4000); // NaN * 2.0 = NaN\n        check_result(C, 0.0/0.0, \"NaN * 2.0\");\n        \n        // Test 8: Subnormal Numbers\n        test_case = 8;\n        $display(\"Test %0d: Subnormal Numbers\", test_case);\n        reset_dut();\n        \n        // 5.96e-8 * 5.96e-8 = 3.55e-15 (underflows to 0 in FP16)\n        multiply_inputs(16'h0001, 16'h0001);\n        check_result(C, 0.0, \"5.96e-8 * 5.96e-8\");\n        \n        // Test 9: Overflow and Underflow\n        test_case = 9;\n        $display(\"Test %0d: Overflow and Underflow\", test_case);\n        reset_dut();\n        \n        // Overflow test: 65504.0 * 1.5 = 98256.0 (overflows to inf in FP16)\n        multiply_inputs(16'h7BFF, 16'h3E00);\n        check_result(C, $itor(1.0)/0.0, \"65504.0 * 1.5\");\n        \n        // Test 10: Edge Cases\n        test_case = 10;\n        $display(\"Test %0d: Edge Cases\", test_case);\n        reset_dut();\n        \n        // Maximum representable value * 1.0\n        multiply_inputs(16'h7BFF, 16'h3C00); // 65504.0 * 1.0\n        check_result(C, 65504.0, \"65504.0 * 1.0\");\n        \n        // Minimum normal * minimum normal\n        multiply_inputs(16'h0400, 16'h0400); // 6.10e-5 * 6.10e-5\n        check_result(C, 3.72e-9, \"6.10e-5 * 6.10e-5\");\n        \n        // Zero * Infinity = NaN\n        multiply_inputs(16'h0000, 16'h7C00);\n        check_result(C, 0.0/0.0, \"0.0 * inf\");\n        \n        // Final result\n        if (error_count == 0) begin\n            $display(\"TestSuccessed: All tests passed!\");\n        end else begin\n            $display(\"TestFailed: %0d errors found\", error_count);\n        end\n        \n        $finish;\n    end\n\nendmodule"
}